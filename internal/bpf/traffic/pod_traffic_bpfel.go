// Code generated by bpf2go; DO NOT EDIT.
//go:build 386 || amd64 || arm || arm64 || loong64 || mips64le || mipsle || ppc64le || riscv64

package traffic

import (
	"bytes"
	_ "embed"
	"fmt"
	"io"

	"github.com/cilium/ebpf"
)

type pod_trafficEventT struct {
	Len      uint32
	Family   uint32
	Protocol uint32
	DstIp4   uint32
	SrcIp4   uint32
	DstIp6   [4]uint32
	SrcIp6   [4]uint32
	SrcPort  uint32
	DstPort  uint16
	_        [2]byte
}

// loadPod_traffic returns the embedded CollectionSpec for pod_traffic.
func loadPod_traffic() (*ebpf.CollectionSpec, error) {
	reader := bytes.NewReader(_Pod_trafficBytes)
	spec, err := ebpf.LoadCollectionSpecFromReader(reader)
	if err != nil {
		return nil, fmt.Errorf("can't load pod_traffic: %w", err)
	}

	return spec, err
}

// loadPod_trafficObjects loads pod_traffic and converts it into a struct.
//
// The following types are suitable as obj argument:
//
//	*pod_trafficObjects
//	*pod_trafficPrograms
//	*pod_trafficMaps
//
// See ebpf.CollectionSpec.LoadAndAssign documentation for details.
func loadPod_trafficObjects(obj interface{}, opts *ebpf.CollectionOptions) error {
	spec, err := loadPod_traffic()
	if err != nil {
		return err
	}

	return spec.LoadAndAssign(obj, opts)
}

// pod_trafficSpecs contains maps and programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type pod_trafficSpecs struct {
	pod_trafficProgramSpecs
	pod_trafficMapSpecs
}

// pod_trafficSpecs contains programs before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type pod_trafficProgramSpecs struct {
	EgressPodTrafficHook  *ebpf.ProgramSpec `ebpf:"egress_pod_traffic_hook"`
	IngressPodTrafficHook *ebpf.ProgramSpec `ebpf:"ingress_pod_traffic_hook"`
}

// pod_trafficMapSpecs contains maps before they are loaded into the kernel.
//
// It can be passed ebpf.CollectionSpec.Assign.
type pod_trafficMapSpecs struct {
	EgressPodTrafficEvents  *ebpf.MapSpec `ebpf:"egress_pod_traffic_events"`
	IngressPodTrafficEvents *ebpf.MapSpec `ebpf:"ingress_pod_traffic_events"`
}

// pod_trafficObjects contains all objects after they have been loaded into the kernel.
//
// It can be passed to loadPod_trafficObjects or ebpf.CollectionSpec.LoadAndAssign.
type pod_trafficObjects struct {
	pod_trafficPrograms
	pod_trafficMaps
}

func (o *pod_trafficObjects) Close() error {
	return _Pod_trafficClose(
		&o.pod_trafficPrograms,
		&o.pod_trafficMaps,
	)
}

// pod_trafficMaps contains all maps after they have been loaded into the kernel.
//
// It can be passed to loadPod_trafficObjects or ebpf.CollectionSpec.LoadAndAssign.
type pod_trafficMaps struct {
	EgressPodTrafficEvents  *ebpf.Map `ebpf:"egress_pod_traffic_events"`
	IngressPodTrafficEvents *ebpf.Map `ebpf:"ingress_pod_traffic_events"`
}

func (m *pod_trafficMaps) Close() error {
	return _Pod_trafficClose(
		m.EgressPodTrafficEvents,
		m.IngressPodTrafficEvents,
	)
}

// pod_trafficPrograms contains all programs after they have been loaded into the kernel.
//
// It can be passed to loadPod_trafficObjects or ebpf.CollectionSpec.LoadAndAssign.
type pod_trafficPrograms struct {
	EgressPodTrafficHook  *ebpf.Program `ebpf:"egress_pod_traffic_hook"`
	IngressPodTrafficHook *ebpf.Program `ebpf:"ingress_pod_traffic_hook"`
}

func (p *pod_trafficPrograms) Close() error {
	return _Pod_trafficClose(
		p.EgressPodTrafficHook,
		p.IngressPodTrafficHook,
	)
}

func _Pod_trafficClose(closers ...io.Closer) error {
	for _, closer := range closers {
		if err := closer.Close(); err != nil {
			return err
		}
	}
	return nil
}

// Do not access this directly.
//
//go:embed pod_traffic_bpfel.o
var _Pod_trafficBytes []byte
